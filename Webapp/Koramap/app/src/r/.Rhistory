for (t in testVect) {
vals <- runif(0:(t-1),min=0,max=100)
units <- c()
while (length(units) < length(vals)) {
units <- append(units,unitOps[sample(1:length(unitOps),t,replace=T)])
}
for (op in 2:2) {
for (m in 1:trials) {
start <- Sys.time()
if (op==1) {
outVect <- c()
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
x <- vals[i]
text <- NA
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text <- conversions[[units[i]]]
}
res <- as.double(eval(parse(text=text)))
outVect <- append(outVect,res)
}
} else {
text <- rep(NA,length(vals))
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text[i] <- gsub('x',vals[i],conversions[[units[i]]])
}
}
outVect <- unlist(parSapply(cl=cl,X=text,FUN=myfun,USE.NAMES=F))
}
end <- Sys.time()
if (op==1) {
op1 <- append(op1,as.numeric(end-start)*1000)
} else {
op2 <- append(op2,as.numeric(end-start)*1000)
}
}
}
}
stopCluster(cl)
op2
library(parallel)
minLen <- 100000
maxLen <- 100000
lenOut <- 1
trials <- 1
wNext <- T
testVect <- seq(from=minLen,to=maxLen,length.out=lenOut)
unitOps <- c('ppm','ppb','ppt','mg/l','g/l','mg/ml','ppq')
conversions <- list('ppm'='x',
'ppb'='x/1000',
'ppt'='x/1000000',
'mg/l'='x',
'g/l'='x/1000',
'mg/ml'='x/1000')
target <- 'ppm'
sockStart <- Sys.time()
cl <- makePSOCKcluster(detectCores())
sockEnd <- Sys.time()
sockElap <- as.numeric(sockEnd-sockStart)*1000
myfun <- function(x) eval(parse(text=x))
op1 <- c()
op2 <- c()
for (t in testVect) {
vals <- runif(0:(t-1),min=0,max=100)
units <- c()
while (length(units) < length(vals)) {
units <- append(units,unitOps[sample(1:length(unitOps),t,replace=T)])
}
for (op in 1:1) {
for (m in 1:trials) {
start <- Sys.time()
if (op==1) {
outVect <- c()
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
x <- vals[i]
text <- NA
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text <- conversions[[units[i]]]
}
res <- as.double(eval(parse(text=text)))
outVect <- append(outVect,res)
}
} else {
text <- rep(NA,length(vals))
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text[i] <- gsub('x',vals[i],conversions[[units[i]]])
}
}
outVect <- unlist(parSapply(cl=cl,X=text,FUN=myfun,USE.NAMES=F))
}
end <- Sys.time()
if (op==1) {
op1 <- append(op1,as.numeric(end-start)*1000)
} else {
op2 <- append(op2,as.numeric(end-start)*1000)
}
}
}
}
stopCluster(cl)
op1
library(parallel)
minLen <- 10
maxLen <- 100000
lenOut <- 10
trials <- 3
wNext <- T
testVect <- seq(from=minLen,to=maxLen,length.out=lenOut)
unitOps <- c('ppm','ppb','ppt','mg/l','g/l','mg/ml','ppq')
conversions <- list('ppm'='x',
'ppb'='x/1000',
'ppt'='x/1000000',
'mg/l'='x',
'g/l'='x/1000',
'mg/ml'='x/1000')
target <- 'ppm'
sockStart <- Sys.time()
cl <- makePSOCKcluster(detectCores())
sockEnd <- Sys.time()
sockElap <- as.numeric(sockEnd-sockStart)*1000
myfun <- function(x) eval(parse(text=x))
op1 <- c()
op2 <- c()
for (t in testVect) {
vals <- runif(0:(t-1),min=0,max=100)
units <- c()
while (length(units) < length(vals)) {
units <- append(units,unitOps[sample(1:length(unitOps),t,replace=T)])
}
for (op in 1:2) {
for (m in 1:trials) {
start <- Sys.time()
if (op==1) {
outVect <- c()
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
x <- vals[i]
text <- NA
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text <- conversions[[units[i]]]
}
res <- as.double(eval(parse(text=text)))
outVect <- append(outVect,res)
}
} else {
text <- rep(NA,length(vals))
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text[i] <- gsub('x',vals[i],conversions[[units[i]]])
}
}
outVect <- unlist(parSapply(cl=cl,X=text,FUN=myfun,USE.NAMES=F))
}
end <- Sys.time()
if (op==1) {
op1 <- append(op1,as.numeric(end-start)*1000)
} else {
op2 <- append(op2,as.numeric(end-start)*1000)
}
}
}
}
stopCluster(cl)
lensVect <- rep(testVect,each=trials)
yStart <- 'op1'
yNext <- 'op2'
if (max(op2) > max(op1)) {
yStart <- 'op2'
yNext <- 'op1'
}
plot(x=lensVect,y=get(yStart),xlab='Measurements (#)',ylab='Processing time (ms)')
points(x=lensVect,y=get(yNext),col='red')
legend(x='bottomright',legend=c(yStart,yNext),fill=c('black','red'))
max(op1)
max(op2)
max(op2)/1000
max(op1)/1000
op2Clust <- op2+sockElap
points(x=lensVect,y=op2Clust,col='blue')
plot(x=lensVect,y=get(yStart),xlab='Measurements (#)',ylab='Processing time (ms)')
points(x=lensVect,y=get(yNext),col='red')
points(x=lensVect,y=op2Clust,col='blue')
legend(x='topleft',legend=c(yStart,yNext),fill=c('black','red'))
plot(x=lensVect,y=get(yStart),xlab='Measurements (#)',ylab='Processing time (ms)')
points(x=lensVect,y=get(yNext),col='red')
points(x=lensVect,y=op2Clust,col='blue')
legend(x='topleft',legend=c(yStart,yNext,'op2+cl setup'),fill=c('black','red'))
plot(x=lensVect,y=get(yStart),xlab='Measurements (#)',ylab='Processing time (ms)')
points(x=lensVect,y=get(yNext),col='red')
points(x=lensVect,y=op2Clust,col='blue')
legend(x='topleft',legend=c(yStart,yNext,'op2+cl setup'),fill=c('black','red','blue'))
?lm
lm(formula=y~x,data=op2Clust)
lm(formula=x~y,data=op2Clust)
lm(formula=x~y,data=data.frame(lensVect,op2Clust))
lm(formula=op2Clust~lensVect,data=data.frame(lensVect,op2Clust))
lm(formula=lensVect~op2Clust,data=data.frame(lensVect,op2Clust))
lm(formula=op2Clust~lensVect,data=data.frame(lensVect,op2Clust))
lm(formula=op1~lensVect,data=data.frame(lensVect,op1))
calcTime <- function (x) {
return(0.2267*x-1342.4621)}
calcTime2 <- function (x) {
return(0.02748*x+876.93248)}
calcTime(10)
calcTime2(10)
op1[1]
op2[1]
op2Clust[1]
lm(formula=op1^2~lensVect,data=data.frame(lensVect,op1))
lm(formula=op1^1.3~lensVect,data=data.frame(lensVect,op1))
lm(formula=op1^0.5~lensVect,data=data.frame(lensVect,op1))
line(lm(formula=op1~lensVect,data=data.frame(lensVect,op1)))
line(lm(formula=op1~lensVect,data=data.frame(lensVect,op1))$Coefficients)
abline(lm(formula=op1~lensVect,data=data.frame(lensVect,op1)))
abline(lm(formula=op1~lensVect))
lm(formula=op1~lensVect)
abline(lm(formula=op2Clust~lensVect),col='blue')
library(parallel)
minLen <- 10
maxLen <- 1000000
lenOut <- 10
trials <- 3
wNext <- T
testVect <- seq(from=minLen,to=maxLen,length.out=lenOut)
unitOps <- c('ppm','ppb','ppt','mg/l','g/l','mg/ml','ppq')
conversions <- list('ppm'='x',
'ppb'='x/1000',
'ppt'='x/1000000',
'mg/l'='x',
'g/l'='x/1000',
'mg/ml'='x/1000')
target <- 'ppm'
sockStart <- Sys.time()
cl <- makePSOCKcluster(detectCores())
sockEnd <- Sys.time()
sockElap <- as.numeric(sockEnd-sockStart)*1000
myfun <- function(x) eval(parse(text=x))
op1 <- c()
op2 <- c()
for (t in testVect) {
vals <- runif(0:(t-1),min=0,max=100)
units <- c()
while (length(units) < length(vals)) {
units <- append(units,unitOps[sample(1:length(unitOps),t,replace=T)])
}
for (op in 1:2) {
for (m in 1:trials) {
start <- Sys.time()
if (op==1) {
outVect <- c()
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
x <- vals[i]
text <- NA
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text <- conversions[[units[i]]]
}
res <- as.double(eval(parse(text=text)))
outVect <- append(outVect,res)
}
} else {
text <- rep(NA,length(vals))
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text[i] <- gsub('x',vals[i],conversions[[units[i]]])
}
}
outVect <- unlist(parSapply(cl=cl,X=text,FUN=myfun,USE.NAMES=F))
}
end <- Sys.time()
if (op==1) {
op1 <- append(op1,as.numeric(end-start)*1000)
} else {
op2 <- append(op2,as.numeric(end-start)*1000)
}
}
}
}
op1
op2
lensVect <- rep(testVect,each=trials)
lensVect
length(lensVect)-length(op1)
lensVect[length(op1)]
lensVect[1:length(op1)]
length <- lensVect[1:length(op1)]
lensVect <- lensVect[1:length(op1)]
yStart <- 'op1'
yNext <- 'op2'
if (max(op2) > max(op1)) {
yStart <- 'op2'
yNext <- 'op1'
}
plot(x=lensVect,y=get(yStart),xlab='Measurements (#)',ylab='Processing time (ms)')
points(x=lensVect,y=get(yNext),col='red')
points(x=lensVect,y=op2Clust,col='blue')
legend(x='topleft',legend=c(yStart,yNext,'op2+cl setup'),fill=c('black','red','blue'))
op2Clust <- op2+sockElap
points(x=lensVect,y=op2Clust,col='blue')
op2
op1
op1
op2
library(parallel)
minLen <- 1000000
maxLen <- 1000000
lenOut <- 1
trials <- 1
wNext <- T
testVect <- seq(from=minLen,to=maxLen,length.out=lenOut)
unitOps <- c('ppm','ppb','ppt','mg/l','g/l','mg/ml','ppq')
conversions <- list('ppm'='x',
'ppb'='x/1000',
'ppt'='x/1000000',
'mg/l'='x',
'g/l'='x/1000',
'mg/ml'='x/1000')
target <- 'ppm'
sockStart <- Sys.time()
cl <- makePSOCKcluster(detectCores())
sockEnd <- Sys.time()
sockElap <- as.numeric(sockEnd-sockStart)*1000
myfun <- function(x) eval(parse(text=x))
op1 <- c()
op2 <- c()
for (t in testVect) {
vals <- runif(0:(t-1),min=0,max=100)
units <- c()
while (length(units) < length(vals)) {
units <- append(units,unitOps[sample(1:length(unitOps),t,replace=T)])
}
for (op in 1:2) {
for (m in 1:trials) {
start <- Sys.time()
if (op==1) {
outVect <- c()
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
x <- vals[i]
text <- NA
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text <- conversions[[units[i]]]
}
res <- as.double(eval(parse(text=text)))
outVect <- append(outVect,res)
}
} else {
text <- rep(NA,length(vals))
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text[i] <- gsub('x',vals[i],conversions[[units[i]]])
}
}
outVect <- unlist(parSapply(cl=cl,X=text,FUN=myfun,USE.NAMES=F))
}
end <- Sys.time()
if (op==1) {
op1 <- append(op1,as.numeric(end-start)*1000)
} else {
op2 <- append(op2,as.numeric(end-start)*1000)
}
}
}
}
library(parallel)
minLen <- 1000000
maxLen <- 1000000
lenOut <- 1
trials <- 1
wNext <- T
testVect <- seq(from=minLen,to=maxLen,length.out=lenOut)
unitOps <- c('ppm','ppb','ppt','mg/l','g/l','mg/ml','ppq')
conversions <- list('ppm'='x',
'ppb'='x/1000',
'ppt'='x/1000000',
'mg/l'='x',
'g/l'='x/1000',
'mg/ml'='x/1000')
target <- 'ppm'
sockStart <- Sys.time()
cl <- makePSOCKcluster(detectCores())
sockEnd <- Sys.time()
sockElap <- as.numeric(sockEnd-sockStart)*1000
myfun <- function(x) eval(parse(text=x))
op1 <- c()
op2 <- c()
for (t in testVect) {
vals <- runif(0:(t-1),min=0,max=100)
units <- c()
while (length(units) < length(vals)) {
units <- append(units,unitOps[sample(1:length(unitOps),t,replace=T)])
}
for (op in 1:2) {
for (m in 1:trials) {
start <- Sys.time()
if (op==1) {
# outVect <- c()
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
x <- vals[i]
text <- NA
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text <- conversions[[units[i]]]
}
res <- as.double(eval(parse(text=text)))
# outVect <- append(outVect,res)
cat(paste(i,length(vals),"/n",sep="/"))
}
} else {
text <- rep(NA,length(vals))
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text[i] <- gsub('x',vals[i],conversions[[units[i]]])
}
}
outVect <- unlist(parSapply(cl=cl,X=text,FUN=myfun,USE.NAMES=F))
}
end <- Sys.time()
if (op==1) {
op1 <- append(op1,as.numeric(end-start)*1000)
} else {
op2 <- append(op2,as.numeric(end-start)*1000)
}
}
}
}
library(parallel)
minLen <- 1000000
maxLen <- 1000000
lenOut <- 1
trials <- 1
wNext <- T
testVect <- seq(from=minLen,to=maxLen,length.out=lenOut)
unitOps <- c('ppm','ppb','ppt','mg/l','g/l','mg/ml','ppq')
conversions <- list('ppm'='x',
'ppb'='x/1000',
'ppt'='x/1000000',
'mg/l'='x',
'g/l'='x/1000',
'mg/ml'='x/1000')
target <- 'ppm'
sockStart <- Sys.time()
cl <- makePSOCKcluster(detectCores())
sockEnd <- Sys.time()
sockElap <- as.numeric(sockEnd-sockStart)*1000
myfun <- function(x) eval(parse(text=x))
op1 <- c()
op2 <- c()
for (t in testVect) {
vals <- runif(0:(t-1),min=0,max=100)
units <- c()
while (length(units) < length(vals)) {
units <- append(units,unitOps[sample(1:length(unitOps),t,replace=T)])
}
for (op in 1:2) {
for (m in 1:trials) {
start <- Sys.time()
if (op==1) {
# outVect <- c()
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
x <- vals[i]
text <- NA
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text <- conversions[[units[i]]]
}
res <- as.double(eval(parse(text=text)))
# outVect <- append(outVect,res)
cat(paste(i,length(vals),"\n",sep="/"))
}
} else {
text <- rep(NA,length(vals))
for (i in 1:length(vals)) {
if (wNext && units[i] == target) next
if (units[i] %in% names(conversions)) {
if (wNext && conversions[[units[i]]] %in% c('x','x*1','x/1')) next
text[i] <- gsub('x',vals[i],conversions[[units[i]]])
}
}
outVect <- unlist(parSapply(cl=cl,X=text,FUN=myfun,USE.NAMES=F))
}
end <- Sys.time()
if (op==1) {
op1 <- append(op1,as.numeric(end-start)*1000)
} else {
op2 <- append(op2,as.numeric(end-start)*1000)
}
}
}
}
