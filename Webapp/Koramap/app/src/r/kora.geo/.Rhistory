r       <- raster(shape.idw)
r.m     <- mask(r, shape)
hist <- raster::hist(r.m,plot=F)
breaks=length(hist$breaks)
extent = bbox(r.m)
w <- ncol(r.m)/max(dim(r.m))
h <- nrow(r.m)/max(dim(r.m))
my_palette <- colorRampPalette(c("green", "yellow", "red"))(n = breaks)
png('out.png',width=480*w,height=480*h,bg='transparent')
plot.new()
par(mar=c(0,0,0,0), oma=c(0,0,0,0), xpd=NA)
plot.window(xlim=extent(r.m)[1:2], ylim=extent(r.m)[3:4], xaxs="i",yaxs="i")
raster::plot(r.m,axes=F,box=F,legend=F,breaks=hist$breaks,col=my_palette,alpha=alpha,add=T)
dev.off()
invisible()
return(r.m)
rastOut <- writeRaster(r.m, filename, 'GTiff')
if (save) {
body = list(guid=guid,filename=filename,file=upload_file(paste(filename,'.tif',sep="")))
POST('http://ecocollector.azurewebsites.net/add_media.php',body=body,encode='application/x-www-form-urlencoded')
}
}
r.m <- shapeidw(shapeString, x, y, z, 50000, 2, 0.5,T,'test','test')
?postscript
?httr
body = list(guid=guid,filename=filename,file=upload_file(paste(filename,'.tif',sep="")))
guid = 'test'
filename = 'test'
body = list(guid=guid,filename=filename,file=upload_file(paste(filename,'.tif',sep="")))
fileupload = httr::upload_file(upload_file(paste(filename,'.tif',sep="")),type='image/tiff')
library(httr)
fileupload = httr::upload_file(upload_file(paste(filename,'.tif',sep="")),type='image/tiff')
setwd('c:\\users\\jonse\\desktop')
fileName <- 'newyork.geo.json'
shapeString <- readChar(fileName, file.info(fileName)$size)
x <- c(-73.941410,-74.952605,-77.620694,-74.965896)
y <- c(40.706953,43.036472,42.653883,44.344027)
z <- c(1.34, 5.76, 2.11, 3.11)
library(rgdal)
library(gstat)
library(sp)
library(raster)
library(httr)
shapejson <- jsonlite::fromJSON(shapeString)
shapecoords <- shapejson$features$geometry$coordinates
polys <- list()
id <- 1
if (shapejson$features$geometry$type == 'MultiPolygon') {
for (i in 1:length(shapecoords)) {
innerpolys <- list()
for (j in 1:length(shapecoords[[i]])) {
innerpolys <- append(innerpolys,Polygon(matrix(shapecoords[[i]][[j]],ncol = 2)))
}
polys <- append(polys,Polygons(innerpolys,id))
id <- id + 1
}
} else if (shapejson$features$geometry$type == 'Polygon') {
innerpolys <- list()
innerpolys <- append(innerpolys,Polygon(matrix(shapecoords[[1]],ncol=2)))
polys <- append(polys,Polygons(innerpolys,id))
}
shape <- SpatialPolygons(Srl=polys, proj4string=CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
remVect <- which(is.na(z))
if (length(remVect) > 0) {
x <- x[-remVect]
y <- y[-remVect]
z <- z[-remVect]
}
point_data <- data.frame(x=x,y=y)
point_data_sp <- SpatialPoints(point_data,proj4string = CRS(proj4string(shape)))
# Create an empty grid where n is the total number of cells
grd              <- as.data.frame(spsample(shape, "regular", n=n))
names(grd)       <- c("X", "Y")
coordinates(grd) <- c("X", "Y")
gridded(grd)     <- TRUE  # Create SpatialPixel object
fullgrid(grd)    <- TRUE  # Create SpatialGrid object
# Add shape's projection information to the empty grid
proj4string(grd) <- proj4string(shape)
# Interpolate the grid cells using a power value of 2 (idp=2.0)
shape.idw <- idw(z ~ 1, point_data_sp, newdata=grd, idp=idp, na.action=na.pass)
# Convert to raster object then clip to shape
r       <- raster(shape.idw)
r.m     <- mask(r, shape)
hist <- raster::hist(r.m,plot=F)
breaks=length(hist$breaks)
extent = bbox(r.m)
w <- ncol(r.m)/max(dim(r.m))
h <- nrow(r.m)/max(dim(r.m))
my_palette <- colorRampPalette(c("green", "yellow", "red"))(n = breaks)
png('out.png',width=480*w,height=480*h,bg='transparent')
plot.new()
par(mar=c(0,0,0,0), oma=c(0,0,0,0), xpd=NA)
plot.window(xlim=extent(r.m)[1:2], ylim=extent(r.m)[3:4], xaxs="i",yaxs="i")
raster::plot(r.m,axes=F,box=F,legend=F,breaks=hist$breaks,col=my_palette,alpha=alpha,add=T)
dev.off()
invisible()
return(r.m)
rastOut <- writeRaster(r.m, filename, 'GTiff')
setwd('c:\\users\\jonse\\desktop')
fileName <- 'newyork.geo.json'
shapeString <- readChar(fileName, file.info(fileName)$size)
x <- c(-73.941410,-74.952605,-77.620694,-74.965896)
y <- c(40.706953,43.036472,42.653883,44.344027)
z <- c(1.34, 5.76, 2.11, 3.11)
n <- 50000
idp <- 2.0
alpha <- 0.5
setwd('c:\\users\\jonse\\desktop')
fileName <- 'newyork.geo.json'
shapeString <- readChar(fileName, file.info(fileName)$size)
x <- c(-73.941410,-74.952605,-77.620694,-74.965896)
y <- c(40.706953,43.036472,42.653883,44.344027)
z <- c(1.34, 5.76, 2.11, 3.11)
n <- 50000
idp <- 2.0
alpha <- 0.5
library(rgdal)
library(gstat)
library(sp)
library(raster)
library(httr)
shapejson <- jsonlite::fromJSON(shapeString)
shapecoords <- shapejson$features$geometry$coordinates
polys <- list()
id <- 1
if (shapejson$features$geometry$type == 'MultiPolygon') {
for (i in 1:length(shapecoords)) {
innerpolys <- list()
for (j in 1:length(shapecoords[[i]])) {
innerpolys <- append(innerpolys,Polygon(matrix(shapecoords[[i]][[j]],ncol = 2)))
}
polys <- append(polys,Polygons(innerpolys,id))
id <- id + 1
}
} else if (shapejson$features$geometry$type == 'Polygon') {
innerpolys <- list()
innerpolys <- append(innerpolys,Polygon(matrix(shapecoords[[1]],ncol=2)))
polys <- append(polys,Polygons(innerpolys,id))
}
shape <- SpatialPolygons(Srl=polys, proj4string=CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
remVect <- which(is.na(z))
if (length(remVect) > 0) {
x <- x[-remVect]
y <- y[-remVect]
z <- z[-remVect]
}
point_data <- data.frame(x=x,y=y)
point_data_sp <- SpatialPoints(point_data,proj4string = CRS(proj4string(shape)))
# Create an empty grid where n is the total number of cells
grd              <- as.data.frame(spsample(shape, "regular", n=n))
names(grd)       <- c("X", "Y")
coordinates(grd) <- c("X", "Y")
gridded(grd)     <- TRUE  # Create SpatialPixel object
fullgrid(grd)    <- TRUE  # Create SpatialGrid object
# Add shape's projection information to the empty grid
proj4string(grd) <- proj4string(shape)
# Interpolate the grid cells using a power value of 2 (idp=2.0)
shape.idw <- idw(z ~ 1, point_data_sp, newdata=grd, idp=idp, na.action=na.pass)
# Convert to raster object then clip to shape
r       <- raster(shape.idw)
r.m     <- mask(r, shape)
hist <- raster::hist(r.m,plot=F)
breaks=length(hist$breaks)
extent = bbox(r.m)
w <- ncol(r.m)/max(dim(r.m))
h <- nrow(r.m)/max(dim(r.m))
my_palette <- colorRampPalette(c("green", "yellow", "red"))(n = breaks)
png('out.png',width=480*w,height=480*h,bg='transparent')
plot.new()
par(mar=c(0,0,0,0), oma=c(0,0,0,0), xpd=NA)
plot.window(xlim=extent(r.m)[1:2], ylim=extent(r.m)[3:4], xaxs="i",yaxs="i")
raster::plot(r.m,axes=F,box=F,legend=F,breaks=hist$breaks,col=my_palette,alpha=alpha,add=T)
dev.off()
invisible()
return(r.m)
rastOut <- writeRaster(r.m, filename, 'GTiff')
rastOut <- writeRaster(r.m, filename, 'GTiff')
names(r.m)
r.m
rastOut <- raster::writeRaster(r.m, filename, 'GTiff')
?writeRaster
?`writeRaster,RasterLayer,character-method`
rastOut <- raster::writeRaster(r.m, filename, 'GTiff')
r.m     <- mask(r, shape)
rastOut <- raster::writeRaster(r.m, filename, 'GTiff')
shapeidw <- function (shapeString, x, y, z, n=50000, idp=2.0, alpha=0.5, save=F, guid=NA, filename=NA) {
library(rgdal)
library(gstat)
library(sp)
library(raster)
library(httr)
shapejson <- jsonlite::fromJSON(shapeString)
shapecoords <- shapejson$features$geometry$coordinates
polys <- list()
id <- 1
if (shapejson$features$geometry$type == 'MultiPolygon') {
for (i in 1:length(shapecoords)) {
innerpolys <- list()
for (j in 1:length(shapecoords[[i]])) {
innerpolys <- append(innerpolys,Polygon(matrix(shapecoords[[i]][[j]],ncol = 2)))
}
polys <- append(polys,Polygons(innerpolys,id))
id <- id + 1
}
} else if (shapejson$features$geometry$type == 'Polygon') {
innerpolys <- list()
innerpolys <- append(innerpolys,Polygon(matrix(shapecoords[[1]],ncol=2)))
polys <- append(polys,Polygons(innerpolys,id))
}
shape <- SpatialPolygons(Srl=polys, proj4string=CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
remVect <- which(is.na(z))
if (length(remVect) > 0) {
x <- x[-remVect]
y <- y[-remVect]
z <- z[-remVect]
}
point_data <- data.frame(x=x,y=y)
point_data_sp <- SpatialPoints(point_data,proj4string = CRS(proj4string(shape)))
# Create an empty grid where n is the total number of cells
grd              <- as.data.frame(spsample(shape, "regular", n=n))
names(grd)       <- c("X", "Y")
coordinates(grd) <- c("X", "Y")
gridded(grd)     <- TRUE  # Create SpatialPixel object
fullgrid(grd)    <- TRUE  # Create SpatialGrid object
# Add shape's projection information to the empty grid
proj4string(grd) <- proj4string(shape)
# Interpolate the grid cells using a power value of 2 (idp=2.0)
shape.idw <- idw(z ~ 1, point_data_sp, newdata=grd, idp=idp, na.action=na.pass)
# Convert to raster object then clip to shape
r       <- raster(shape.idw)
r.m     <- mask(r, shape)
hist <- raster::hist(r.m,plot=F)
breaks=length(hist$breaks)
extent = bbox(r.m)
w <- ncol(r.m)/max(dim(r.m))
h <- nrow(r.m)/max(dim(r.m))
my_palette <- colorRampPalette(c("green", "yellow", "red"))(n = breaks)
png('out.png',width=480*w,height=480*h,bg='transparent')
plot.new()
par(mar=c(0,0,0,0), oma=c(0,0,0,0), xpd=NA)
plot.window(xlim=extent(r.m)[1:2], ylim=extent(r.m)[3:4], xaxs="i",yaxs="i")
raster::plot(r.m,axes=F,box=F,legend=F,breaks=hist$breaks,col=my_palette,alpha=alpha,add=T)
dev.off()
invisible()
return(r.m)
}
setwd('c:\\users\\jonse\\desktop')
fileName <- 'newyork.geo.json'
shapeString <- readChar(fileName, file.info(fileName)$size)
x <- c(-73.941410,-74.952605,-77.620694,-74.965896)
y <- c(40.706953,43.036472,42.653883,44.344027)
z <- c(1.34, 5.76, 2.11, 3.11)
n <- 50000
idp <- 2.0
alpha <- 0.5
r.m <- shapeidw(shapeString, x, y, z, 50000, 2, 0.5)
rastOut <- raster::writeRaster(r.m, filename, 'GTiff')
class(r.m)
rastOut <- raster::writeRaster(r.m, filename, 'GTiff')
class(filename)
rastOut <- raster::writeRaster(r.m, fileName, 'GTiff')
save
save = T
save
save <- T
filename <- 'test'
rastOut <- raster::writeRaster(r.m, filename, 'GTiff')
fileupload = httr::upload_file(upload_file(paste(filename,'.tif',sep="")),type='image/tiff')
paste(filename,'.tif',sep="")
paste(filename,'.tif',sep=""))
fileupload = httr::upload_file(paste(filename,'.tif',sep=""),type='image/tiff')
class(fileUpload)
class(fileupload)
body = list(guid=guid,filename=filename,file=fileupload)
guid <- 'f2e0b43f-0760-425a-b36d-109e65531b5c'
body = list(guid=guid,filename=filename,file=fileupload)
httr::POST('http://ecocollector.azurewebsites.net/add_media.php',body=body,encode='application/x-www-form-urlencoded')
?httr::POST
httr::POST('http://ecocollector.azurewebsites.net/add_media.php',body=body,encode='form')
httr::POST('http://ecocollector.azurewebsites.net/add_media.php',body=body,encode=c('form'))
url = 'http://ecocollector.azurewebsites.net/add_media.php'
httr::POST(url=url,body=body,encode=c('form'))
url = "http://ecocollector.azurewebsites.net/add_media.php"
httr::POST(url=url,body=body,encode=c('form'))
class(url)
httr::POST(url=url,body=body,encode=c('json'))
body = list(file=fileupload)
httr::POST(url=url,body=body,encode=c('json'))
httr::POST(url=url,body=body,encode=c('form'))
httr::POST(url=url,body=body,encode="form")
httr::POST(url=url,body=body,encode="multipart")
result <- httr::POST(url=url,body=body,encode="multipart")
result
names(result)
result(handle)
result$content
result$status_code
result$request
result$handle
http_status(result)
content(result,'text')
url <- "http://ecocollector.azurewebsites.net/add_media.php"
fileupload <- httr::upload_file(paste(filename,'.tif',sep=""),type='image/tiff')
body <- list(GUID=guid,filename=filename,file=fileupload)
result <- httr::POST(url=url,body=body,encode="multipart")
content(result,'text')
content(result,'text')
body
content(result,'text')
body(result)
url <- "http://ecocollector.azurewebsites.net/add_media.php"
fileupload <- httr::upload_file(paste(filename,'.tif',sep=""),type='image/tiff')
body <- list(GUID=guid,filename=filename,file=fileupload)
result <- httr::POST(url=url,body=body,encode="multipart")
content(result,'text')
body <- list('GUID'=guid,'filename'=filename,'file'=fileupload)
result <- httr::POST(url=url,body=body,encode="multipart")
content(result,'text')
names(body)
guid
filename
fileupload
result <- httr::POST(url=url,body=body,encode="multipart")
content(result,'text')
result <- httr::POST(url=url,body=body,encode="multipart")
content(result,'text')
install.packages("base64enc")
library(base64enc)
?base64encode
fileupload <- base64encode(paste(filename,'.tif',sep=""))
body <- list('GUID'=guid,'filename'=filename,'file'=fileupload)
result <- httr::POST(url=url,body=body,encode="multipart")
content(result,'text')
proc.time()
system.time()
system.date()
Sys.Date()
setwd('c:\\users\\jonse\\desktop')
fileName <- 'newyork.geo.json'
shapeString <- readChar(fileName, file.info(fileName)$size)
x <- c(-73.941410,-74.952605,-77.620694,-74.965896)
y <- c(40.706953,43.036472,42.653883,44.344027)
z <- c(1.34, 5.76, 2.11, 3.11)
n <- 50000
idp <- 2.0
alpha <- 0.5
guid <- "f2e0b43f-0760-425a-b36d-109e65531b5c"
save <- T
filename <- 'test'
r.m <- shapeidw(shapeString, x, y, z, 50000, 2, 0.5,save,guid,filename)
shapeidw <- function (shapeString, x, y, z, n=50000, idp=2.0, alpha=0.5, save=F, guid=NA, filename=NA) {
library(rgdal)
library(gstat)
library(sp)
library(raster)
library(httr)
library(base64enc)
shapejson <- jsonlite::fromJSON(shapeString)
shapecoords <- shapejson$features$geometry$coordinates
polys <- list()
id <- 1
if (shapejson$features$geometry$type == 'MultiPolygon') {
for (i in 1:length(shapecoords)) {
innerpolys <- list()
for (j in 1:length(shapecoords[[i]])) {
innerpolys <- append(innerpolys,Polygon(matrix(shapecoords[[i]][[j]],ncol = 2)))
}
polys <- append(polys,Polygons(innerpolys,id))
id <- id + 1
}
} else if (shapejson$features$geometry$type == 'Polygon') {
innerpolys <- list()
innerpolys <- append(innerpolys,Polygon(matrix(shapecoords[[1]],ncol=2)))
polys <- append(polys,Polygons(innerpolys,id))
}
shape <- SpatialPolygons(Srl=polys, proj4string=CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
remVect <- which(is.na(z))
if (length(remVect) > 0) {
x <- x[-remVect]
y <- y[-remVect]
z <- z[-remVect]
}
point_data <- data.frame(x=x,y=y)
point_data_sp <- SpatialPoints(point_data,proj4string = CRS(proj4string(shape)))
# Create an empty grid where n is the total number of cells
grd              <- as.data.frame(spsample(shape, "regular", n=n))
names(grd)       <- c("X", "Y")
coordinates(grd) <- c("X", "Y")
gridded(grd)     <- TRUE  # Create SpatialPixel object
fullgrid(grd)    <- TRUE  # Create SpatialGrid object
# Add shape's projection information to the empty grid
proj4string(grd) <- proj4string(shape)
# Interpolate the grid cells using a power value of 2 (idp=2.0)
shape.idw <- idw(z ~ 1, point_data_sp, newdata=grd, idp=idp, na.action=na.pass)
# Convert to raster object then clip to shape
r       <- raster(shape.idw)
r.m     <- mask(r, shape)
hist <- raster::hist(r.m,plot=F)
breaks=length(hist$breaks)
extent = bbox(r.m)
w <- ncol(r.m)/max(dim(r.m))
h <- nrow(r.m)/max(dim(r.m))
my_palette <- colorRampPalette(c("green", "yellow", "red"))(n = breaks)
png('out.png',width=480*w,height=480*h,bg='transparent')
plot.new()
par(mar=c(0,0,0,0), oma=c(0,0,0,0), xpd=NA)
plot.window(xlim=extent(r.m)[1:2], ylim=extent(r.m)[3:4], xaxs="i",yaxs="i")
raster::plot(r.m,axes=F,box=F,legend=F,breaks=hist$breaks,col=my_palette,alpha=alpha,add=T)
dev.off()
rastOut <- raster::writeRaster(r.m, filename, 'GTiff')
if (save) {
url <- "http://ecocollector.azurewebsites.net/add_media.php"
fileupload <- base64encode(paste(filename,'.tif',sep=""))
body <- list('GUID'=guid,'filename'=paste('model',filename,gsub("-","_",Sys.Date()),sep="_"),'file'=fileupload)
result <- httr::POST(url=url,body=body,encode="multipart")
}
invisible()
}
setwd('c:\\users\\jonse\\desktop')
fileName <- 'newyork.geo.json'
shapeString <- readChar(fileName, file.info(fileName)$size)
x <- c(-73.941410,-74.952605,-77.620694,-74.965896)
y <- c(40.706953,43.036472,42.653883,44.344027)
z <- c(1.34, 5.76, 2.11, 3.11)
n <- 50000
idp <- 2.0
alpha <- 0.5
guid <- "f2e0b43f-0760-425a-b36d-109e65531b5c"
save <- T
filename <- 'test'
r.m <- shapeidw(shapeString, x, y, z, 50000, 2, 0.5,save,guid,filename)
shapeidw <- function (shapeString, x, y, z, n=50000, idp=2.0, alpha=0.5, save=F, guid=NA, filename=NA) {
library(rgdal)
library(gstat)
library(sp)
library(raster)
library(httr)
library(base64enc)
shapejson <- jsonlite::fromJSON(shapeString)
shapecoords <- shapejson$features$geometry$coordinates
polys <- list()
id <- 1
if (shapejson$features$geometry$type == 'MultiPolygon') {
for (i in 1:length(shapecoords)) {
innerpolys <- list()
for (j in 1:length(shapecoords[[i]])) {
innerpolys <- append(innerpolys,Polygon(matrix(shapecoords[[i]][[j]],ncol = 2)))
}
polys <- append(polys,Polygons(innerpolys,id))
id <- id + 1
}
} else if (shapejson$features$geometry$type == 'Polygon') {
innerpolys <- list()
innerpolys <- append(innerpolys,Polygon(matrix(shapecoords[[1]],ncol=2)))
polys <- append(polys,Polygons(innerpolys,id))
}
shape <- SpatialPolygons(Srl=polys, proj4string=CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
remVect <- which(is.na(z))
if (length(remVect) > 0) {
x <- x[-remVect]
y <- y[-remVect]
z <- z[-remVect]
}
point_data <- data.frame(x=x,y=y)
point_data_sp <- SpatialPoints(point_data,proj4string = CRS(proj4string(shape)))
# Create an empty grid where n is the total number of cells
grd              <- as.data.frame(spsample(shape, "regular", n=n))
names(grd)       <- c("X", "Y")
coordinates(grd) <- c("X", "Y")
gridded(grd)     <- TRUE  # Create SpatialPixel object
fullgrid(grd)    <- TRUE  # Create SpatialGrid object
# Add shape's projection information to the empty grid
proj4string(grd) <- proj4string(shape)
# Interpolate the grid cells using a power value of 2 (idp=2.0)
shape.idw <- idw(z ~ 1, point_data_sp, newdata=grd, idp=idp, na.action=na.pass)
# Convert to raster object then clip to shape
r       <- raster(shape.idw)
r.m     <- mask(r, shape)
hist <- raster::hist(r.m,plot=F)
breaks=length(hist$breaks)
extent = bbox(r.m)
w <- ncol(r.m)/max(dim(r.m))
h <- nrow(r.m)/max(dim(r.m))
my_palette <- colorRampPalette(c("green", "yellow", "red"))(n = breaks)
png('out.png',width=480*w,height=480*h,bg='transparent')
plot.new()
par(mar=c(0,0,0,0), oma=c(0,0,0,0), xpd=NA)
plot.window(xlim=extent(r.m)[1:2], ylim=extent(r.m)[3:4], xaxs="i",yaxs="i")
raster::plot(r.m,axes=F,box=F,legend=F,breaks=hist$breaks,col=my_palette,alpha=alpha,add=T)
dev.off()
rastOut <- raster::writeRaster(r.m, filename, 'GTiff',overwrite=T)
if (save) {
url <- "http://ecocollector.azurewebsites.net/add_media.php"
fileupload <- base64encode(paste(filename,'.tif',sep=""))
body <- list('GUID'=guid,'filename'=paste('model',filename,gsub("-","_",Sys.Date()),sep="_"),'file'=fileupload)
result <- httr::POST(url=url,body=body,encode="multipart")
}
invisible()
}
setwd('c:\\users\\jonse\\desktop')
fileName <- 'newyork.geo.json'
shapeString <- readChar(fileName, file.info(fileName)$size)
x <- c(-73.941410,-74.952605,-77.620694,-74.965896)
y <- c(40.706953,43.036472,42.653883,44.344027)
z <- c(1.34, 5.76, 2.11, 3.11)
n <- 50000
idp <- 2.0
alpha <- 0.5
guid <- "f2e0b43f-0760-425a-b36d-109e65531b5c"
save <- T
filename <- 'test'
r.m <- shapeidw(shapeString, x, y, z, 50000, 2, 0.5,save,guid,filename)
